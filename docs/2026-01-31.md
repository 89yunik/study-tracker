# 🗓️ 학습 로그

## ✅ 목표

- 회사 업무
- 지원 회사 탐색

## ✅ 학습 내용

### DB 인덱스 기본 개념 정리

- 인덱스는 테이블 데이터를 빠르게 찾기 위한 정렬된 탐색 구조(B-Tree 기반)
- LINQ나 SQL은 인덱스 유무와 관계없이 항상 동작하며, 인덱스는 DB 엔진의 검색 성능을 개선하는 역할
- 인덱스는 조회 성능을 향상시키는 대신 쓰기 성능과 저장 공간 비용이 증가함

---

### PK, Unique, FK 인덱스 동작 방식 이해

- Primary Key 생성 시 MSSQL에서는 자동으로 인덱스가 생성됨 (대개 Clustered Index)
- Unique 제약조건을 생성하면 내부적으로 Unique Index가 자동 생성되어 성능 구조는 동일
- Foreign Key는 MSSQL에서 자동 인덱스가 생성되지 않으므로 조인 및 참조 성능을 위해 직접 인덱스 생성이 필요

---

### Unique Constraint vs Unique Index 차이

**Unique Constraint**
- 데이터 무결성 규칙 목적
- 자동으로 유니크 인덱스 생성

**Unique Index**
- 성능 튜닝 목적
- Filtered Index, INCLUDE 등 확장 기능 사용 가능

> 비즈니스 규칙은 Constraint, 성능 최적화는 Index로 구분하는 것이 실무적으로 적절

---

### Clustered Index vs Nonclustered Index

**Clustered Index**
- 테이블 데이터 자체가 인덱스 키 기준으로 정렬 저장
- 테이블당 1개만 생성 가능
- 범위 조회에 매우 효율적
- 보통 PK에 적용

**Nonclustered Index**
- 별도 인덱스 구조에 키와 실제 데이터 위치 저장
- 여러 개 생성 가능
- 조회 성능 최적화용

---

### FK 인덱스와 쓰기 성능의 관계

- Create/Update/Delete가 발생해도 FK 인덱스는 대부분 적용하는 것이 유리
- 조인 성능 개선 + 참조 무결성 검사 성능 향상이 쓰기 비용 증가보다 효과가 큼
- 예외: 로그성 테이블, 초고쓰기 테이블, 단기 데이터 테이블

---

### DB별 FK 인덱스 자동 생성 차이

- MSSQL, PostgreSQL, Oracle → 자동 생성 안 됨
- MySQL(InnoDB) → FK 생성 시 자동 인덱스 생성

---

### 인덱스 생성 판단 기준 정리

- PK: 자동 생성 → 별도 생성 불필요
- Unique: 중복 방지 목적이면 거의 필수
- FK: 조인/참조되면 대부분 필수
- 일반 컬럼:
  - 자주 조회됨
  - 쿼리 패턴 고정
  - 데이터 계속 증가  
  → 이 조건이 맞을 때만 인덱스 생성

---

### Read/Write 비율 기반 인덱스 전략

- 읽기 중심 테이블 → 인덱스 적극 적용
- 쓰기 중심 테이블(로그, 이벤트) → 인덱스 최소화
- Reads : Writes 비율이 높을수록 인덱스 ROI 증가

---

## ✍️ 정리 인사이트

- 인덱스는 “많이 만드는 것”이 아니라 “ROI 높은 쿼리에만 정확히 적용하는 기술”
- MSSQL 환경에서는 FK 인덱스 직접 관리가 성능의 핵심 포인트
- Unique 제약과 인덱스는 목적(무결성 vs 성능)을 기준으로 구분해서 사용해야 함